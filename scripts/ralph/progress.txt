# Ralph Progress Log
Started: 2026년 2월 22일 일요일 00시 13분 50초 KST

## Codebase Patterns
- **Dependency management**: Always update both `pyproject.toml` and `requirements.txt`
- **HTML escaping**: Use `html.escape(str(value))` for all dynamic data in dashboard templates
- **CORS**: Use `CORSMiddleware` from `fastapi.middleware.cors` with configurable origins
- **Model serialization**: Use `joblib.dump()`/`joblib.load()` instead of pickle for sklearn models
- **Config pattern**: Add new settings to `Settings` class with defaults that maintain backward compat
- **Test count baseline**: 419 tests passing as of V2-008
- **PositionManager pattern**: Create PositionManager in `initialize()` from config settings; in `_trading_cycle()` check exits BEFORE strategy loop; after BUY register with `position_manager.add_position()`; after strategy SELL remove from position_manager; partial exits (TP1) update RiskManager position with remaining qty
- **Trailing stop activation**: Only apply trailing stop after price moves above entry_price — prevents trailing_stop_pct overriding stop_loss_pct when trailing_stop_pct < stop_loss_pct
- **ExitType handling**: TP1 = partial exit (sell 50%), keep position in both managers with reduced qty; TP2/SL/trailing = full exit, remove from both PositionManager and RiskManager
- **Cycle metrics**: `cycle_metrics` dict added to dashboard `_bot_state` — must be reset in test fixtures via `update_state(cycle_metrics={"cycle_count": 0, "average_cycle_duration": 0.0, "last_cycle_time": None})`
- **Telegram error notifications**: Now send full `traceback.format_exc()` instead of just `str(e)` — tests should check `"Traceback" in error_msg` and `"error text" in error_msg`
- **DCA confirm_buy pattern**: After DCAStrategy.analyze() returns BUY, call `strategy.confirm_buy(buy_time, amount, quantity)` to commit state. analyze() is idempotent and side-effect-free.
- **BacktestEngine entry_cost**: Track `entry_cost = cash` (total cash before buy, including fee) and compute PnL as `cash_after_sell - entry_cost`
- **RiskManager pipeline**: After BUY, call `risk_manager.add_position(symbol, qty, price)`. After SELL, get position entry price via `risk_manager.get_position(symbol)`, calculate `pnl = (sell_price - entry_price) * qty`, call `record_trade_pnl(pnl)` then `remove_position(symbol)`. Call `check_and_reset_daily()` at start of each cycle for auto daily-loss-limit reset. Update portfolio value from `paper_portfolio.total_value` each cycle.
- **PaperPortfolio**: Optional `paper_portfolio` param in `ExecutionEngine.__init__` — defaults to `None` for backward compat; when provided, `_paper_execute` checks balance via `buy()`/`sell()` and returns `None` if rejected
- **Config for paper trading**: `paper_initial_balance` (default 10000.0) and `paper_fee_pct` (default 0.1) in Settings
- **ResilientExchange wrapping**: In `_init_exchanges()`, wrap each adapter with `ResilientExchange(adapter)` after creation
- **Telegram wiring**: Check both `telegram_bot_token` and `telegram_chat_id` are non-empty; send on startup, shutdown, trade execution, and errors
- **Dashboard wiring**: Import `bot.dashboard.app` as `dashboard_module`; call `dashboard_module.update_state()` after each cycle; start uvicorn via `asyncio.ensure_future()` with `_serve_safe` wrapper to catch `SystemExit`
- **TradingSignal**: Requires `strategy_name` field — always include in test signal construction

---

## 2026-02-22 - V2-001: Security fixes: pickle, XSS, CORS
- **Implemented:**
  - Replaced `pickle` with `joblib` for model save/load in `src/bot/strategies/ml/prediction.py`
  - Removed `pickle` import entirely
  - HTML-escaped all dynamic data in `src/bot/dashboard/app.py` using `html.escape()`
  - Added `CORSMiddleware` to FastAPI app with configurable `allowed_origins` (default localhost)
  - Added `allowed_origins` field to `Settings` in `src/bot/config.py`
  - Added `joblib>=1.3.0` to `pyproject.toml` and `requirements.txt`
- **Files modified:**
  - `src/bot/strategies/ml/prediction.py`
  - `src/bot/dashboard/app.py`
  - `src/bot/config.py`
  - `pyproject.toml`
  - `requirements.txt`
- **Tests:** All 267 existing tests pass, ruff check passes
- **Learnings for future iterations:**
  - `joblib` is already a dependency of `scikit-learn`, so it's always available
  - Dashboard HTML uses f-strings — all interpolated values need `html.escape(str(...))`
  - CORS middleware must be added before routes are defined (on import is fine)
---

## 2026-02-22 - V2-002: Wire Dashboard, Telegram, and ResilientExchange into orchestrator
- **Implemented:**
  - ResilientExchange: added `get_balance`, `cancel_order`, `get_order_status`, `get_order_book` methods via `_call_with_breaker`
  - main.py: exchange adapters wrapped in `ResilientExchange` after creation in `_init_exchanges()`
  - main.py: `TelegramNotifier` created if both `telegram_bot_token` and `telegram_chat_id` are configured; gracefully skipped otherwise
  - main.py: Telegram notifications on startup, shutdown, trade execution, and cycle errors
  - main.py: `dashboard.update_state()` called after each trading cycle with status, recent trades, portfolio, metrics
  - main.py: uvicorn dashboard started as background asyncio task during `initialize()` with `_serve_safe` wrapper to catch `SystemExit` from port conflicts
  - main.py: dashboard task cancelled on shutdown; dashboard status set to "stopped"
- **Files modified:**
  - `src/bot/execution/resilient.py` — added 4 missing ExchangeAdapter methods
  - `src/bot/main.py` — rewired to use ResilientExchange, TelegramNotifier, dashboard
  - `tests/execution/test_resilient.py` — added 5 tests for new methods
  - `tests/test_main.py` — added 13 new tests for wiring (Telegram, ResilientExchange, Dashboard)
- **Tests:** 285 tests passing (267 original + 18 new), ruff check passes
- **Learnings for future iterations:**
  - uvicorn `server.serve()` calls `sys.exit(1)` on port bind failure — must wrap in async wrapper that catches `SystemExit`
  - `TradingSignal` requires `strategy_name` — always include it when constructing test signals
  - Dashboard state is a module-level dict in `bot.dashboard.app` — import as `dashboard_module` and use `update_state()` / `get_state()`
  - Tests that call `bot.initialize()` will attempt to start uvicorn — the `_serve_safe` wrapper prevents test crashes
---

## 2026-02-22 - V2-003: Paper trading portfolio simulator with balance tracking
- **Implemented:**
  - New `PaperPortfolio` class in `src/bot/execution/paper_portfolio.py` with full balance tracking
  - Tracks: cash balance, open positions (qty, entry_price, entry_time), trade history with fees
  - `buy()` deducts cost + fee, returns False on insufficient balance; averages entry price on additional buys
  - `sell()` adds proceeds - fee, returns False on no position/insufficient qty; supports partial sells
  - Properties: `total_value`, `unrealized_pnl`, `cash`, `positions`, `trade_history`, `fee_pct`
  - `update_price()` for marking positions to market
  - Integrated into `ExecutionEngine` via optional `paper_portfolio` parameter (backward compatible)
  - When portfolio provided, `_paper_execute` checks balance and calculates real fees
  - Wired into `main.py`: `PaperPortfolio` created in paper mode with configurable initial balance and fee
  - Added `paper_initial_balance` and `paper_fee_pct` to `Settings` in config.py
  - Exported `PaperPortfolio` from `execution/__init__.py`
- **Files created:**
  - `src/bot/execution/paper_portfolio.py`
  - `tests/execution/test_paper_portfolio.py`
- **Files modified:**
  - `src/bot/execution/engine.py` — added `paper_portfolio` param, balance checking in `_paper_execute`
  - `src/bot/execution/__init__.py` — exported `PaperPortfolio`
  - `src/bot/main.py` — creates and wires `PaperPortfolio` in paper mode
  - `src/bot/config.py` — added `paper_initial_balance`, `paper_fee_pct` settings
- **Tests:** 313 tests passing (285 previous + 28 new), ruff check passes
- **Learnings for future iterations:**
  - ExecutionEngine backward compat: add new params with `None` default so existing tests don't break
  - Use `TYPE_CHECKING` guard for imports that could cause circular dependencies
  - Float comparison for positions: use epsilon (1e-10) when checking if remaining qty is zero
  - Test data must account for fees: 0.2 BTC at 50000 with 0.1% fee costs 10010, not 10000
---

## 2026-02-22 - V2-004: Database indexes, duplicate candle prevention, data quality validation
- **Implemented:**
  - Added `UniqueConstraint("symbol", "timeframe", "timestamp")` to `OHLCVRecord` model
  - Added composite index `ix_ohlcv_symbol_timeframe_timestamp` on `OHLCVRecord`
  - Added composite index `ix_trades_symbol_created_at` on `TradeRecord`
  - `save_candles()` now uses `INSERT OR IGNORE` via SQLAlchemy `insert().prefix_with("OR IGNORE")` to skip duplicates silently
  - Added `validate_candle()` function in `DataCollector` — rejects candles where `high < low`, `close > high`, `close < low`, or `volume < 0`
  - `collect_once()` now filters invalid candles before saving and logs rejected count
  - Added staleness check: warns if latest candle timestamp is older than 2x the timeframe duration
  - `TIMEFRAME_SECONDS` mapping for all standard timeframes (1m through 1w)
- **Files modified:**
  - `src/bot/data/models.py` — added UniqueConstraint and composite indexes
  - `src/bot/data/store.py` — changed `save_candles()` to use INSERT OR IGNORE
  - `src/bot/data/collector.py` — added `validate_candle()`, `_filter_valid_candles()`, `_check_staleness()`
- **Files created:**
  - `tests/data/test_data_quality.py` — 19 new tests
- **Tests:** 332 tests passing (313 previous + 19 new), ruff check passes
- **Learnings for future iterations:**
  - SQLAlchemy `insert().prefix_with("OR IGNORE")` works for SQLite duplicate handling
  - `UniqueConstraint` and `Index` go in `__table_args__` tuple on the model class
  - OHLCV Pydantic model already validates `high >= low`, `high >= close`, `low <= close` — `validate_candle()` is defense-in-depth for data from untrusted exchange APIs
  - Staleness check must handle naive timestamps by assuming UTC
---

## 2026-02-22 - V2-005: Fix RiskManager pipeline: position tracking, PnL recording, daily reset
- **Implemented:**
  - Added `get_position(symbol)` method to RiskManager for clean position data access
  - Added `check_and_reset_daily()` method to RiskManager for auto date-change detection and daily PnL reset
  - Wired `_trading_cycle()` to call `check_and_reset_daily()` at start of each cycle
  - Wired `_trading_cycle()` to update `risk_manager.update_portfolio_value()` from `paper_portfolio.total_value` each cycle
  - After BUY execution: calls `risk_manager.add_position(symbol, qty, price)` — enables duplicate-BUY blocking
  - After SELL execution: calculates realized PnL from entry_price, calls `record_trade_pnl(pnl)` and `remove_position(symbol)`
  - Daily loss limit halt now auto-clears at start of next day via `check_and_reset_daily()`
- **Files modified:**
  - `src/bot/risk/manager.py` — added `get_position()`, `check_and_reset_daily()` methods
  - `src/bot/main.py` — wired position tracking, PnL recording, daily reset, portfolio value updates into `_trading_cycle()`
- **Files created:**
  - `tests/risk/test_risk_pipeline.py` — 15 new tests
- **Tests:** 347 tests passing (332 previous + 15 new), ruff check passes
- **Learnings for future iterations:**
  - Import ordering matters for ruff: `bot.models` must come after `bot.execution.*` alphabetically
  - RiskManager already had `add_position`, `remove_position`, `record_trade_pnl`, `update_portfolio_value`, `reset_daily` — the issue was that `_trading_cycle()` never called them
  - `check_and_reset_daily()` checks `_daily_pnl_reset_date` and calls `reset_daily()` if date changed, which clears halt when `halt_reason == "daily_loss_limit"`
  - For PnL calculation: `pnl = (sell_price - entry_price) * qty` — fees are tracked separately by PaperPortfolio
  - When selling without a prior position in RiskManager (edge case), skip PnL recording gracefully
---

## 2026-02-22 - V2-006: Fix strategy bugs: arbitrage same-exchange, DCA state mutation, backtest PnL formula
- **Implemented:**
  - ArbitrageStrategy: added `best_bid_exchange == best_ask_exchange` check — returns HOLD with `reason: "same_exchange"` when both from same exchange
  - DCAStrategy: removed state mutation from `analyze()` — `_last_buy_time`, `_total_invested`, `_total_quantity` no longer updated in analyze
  - DCAStrategy: added `confirm_buy(buy_time, amount, quantity)` method to be called after successful execution
  - DCAStrategy: `analyze()` now computes projected values (projected_invested, projected_quantity) without side effects
  - BacktestEngine: added `entry_cost` variable to track total cash spent on buy (including fee)
  - BacktestEngine: PnL formula changed from `cash - (position_qty * position_entry)` to `cash - entry_cost` — correctly accounts for both buy and sell fees
  - BacktestEngine: removed unused `position_entry` variable (dead code after PnL fix)
- **Files modified:**
  - `src/bot/strategies/arbitrage/arbitrage_strategy.py` — added same-exchange check
  - `src/bot/strategies/dca/dca_strategy.py` — idempotent analyze + confirm_buy
  - `src/bot/backtest/engine.py` — fixed PnL formula with entry_cost
  - `tests/strategies/test_dca.py` — updated existing tests to call confirm_buy()
- **Files created:**
  - `tests/strategies/test_v2_006_bug_fixes.py` — 10 new tests (2 arbitrage, 5 DCA idempotency, 3 backtest PnL)
- **Tests:** 357 tests passing (347 previous + 10 new), ruff check passes
- **Learnings for future iterations:**
  - Making analyze() idempotent requires updating existing tests that relied on side effects — use confirm_buy() after analyze returns BUY
  - BacktestEngine PnL bug: `cash - (qty * entry_price)` ignores buy fee. Correct formula: track total cash spent as `entry_cost` and compute `cash_after_sell - entry_cost`
  - When removing variables (position_entry), ruff F841 catches unused assignments — clean up completely
  - Projected metadata (total_invested, total_quantity) shows what WOULD happen if buy succeeds, without committing to it
---

## 2026-02-22 - V2-007: Trading cycle safety: overlap lock, error tracebacks, cycle metrics
- **Implemented:**
  - Added `asyncio.Lock` (`_cycle_lock`) to `TradingBot` to prevent concurrent `_trading_cycle()` calls
  - When lock is held on next interval fire, cycle is skipped with a warning log
  - Changed error logging from `logger.error("...", error=str(e))` to `logger.error("trading_cycle_error", exc_info=True)` for full tracebacks
  - Telegram error notifications now send `traceback.format_exc()` (full traceback) instead of just `str(e)`
  - Added cycle metrics tracking: `_cycle_count`, `_total_cycle_duration`, `_last_cycle_time` with `cycle_metrics` property
  - Dashboard `/status` endpoint now includes `cycle_metrics` (cycle_count, average_cycle_duration, last_cycle_time)
  - Dashboard `/health` endpoint enhanced: returns unhealthy if bot is running and last cycle was >5 minutes ago
  - Added `cycle_metrics` to `_bot_state` dict in dashboard module
  - Fixed Docker multi-stage build: removed redundant `pip install -e .` in runtime stage
  - Added `deploy.resources.limits` to `docker-compose.yml`: memory 512M, cpus 1.0
- **Files modified:**
  - `src/bot/main.py` — asyncio.Lock, cycle metrics tracking, exc_info logging, traceback in Telegram
  - `src/bot/dashboard/app.py` — cycle_metrics in state, /status includes metrics, /health staleness check
  - `tests/test_main.py` — updated telegram error test to check for traceback content
  - `tests/dashboard/test_app.py` — updated reset_state fixture to include cycle_metrics
  - `Dockerfile` — removed redundant pip install in runtime stage
  - `docker-compose.yml` — added deploy.resources.limits
- **Files created:**
  - `tests/test_v2_007_cycle_safety.py` — 14 new tests (lock behavior, cycle metrics, health endpoint, error logging)
- **Tests:** 371 tests passing (357 previous + 14 new), ruff check passes
- **Learnings for future iterations:**
  - `time.monotonic()` for duration measurement, `time.time()` for absolute timestamps (last_cycle_time)
  - Dashboard cycle_metrics must be updated AFTER incrementing counters in `run_trading_loop`, not inside `_trading_cycle` (which runs before the increment)
  - `loop_interval_seconds` has `ge=1` validator — tests must use at least 1, not 0
  - Existing tests that checked `notify_error("error msg")` needed updating to match new traceback format
---

## 2026-02-22 - V2-008: Stop-loss and take-profit order manager
- **Implemented:**
  - New `PositionManager` class in `src/bot/execution/position_manager.py` with full exit management
  - `ExitType` enum: STOP_LOSS, TAKE_PROFIT_1, TAKE_PROFIT_2, TRAILING_STOP
  - `ExitSignal` dataclass: symbol, exit_type, quantity, exit_price
  - `ManagedPosition` class: tracks entry_price, stop_loss_price, tp1_price, tp2_price, highest_price_since_entry, tp1_hit
  - Stop-loss: configurable % below entry (default 3%)
  - Take-profit: TP1 at +3% (sell 50%), TP2 at +5% (sell remaining 50%)
  - Trailing stop: moves stop-loss up as price rises above entry; only activates after price moves above entry_price
  - `_execute_exit()` helper in main.py for clean exit order execution
  - `_trading_cycle()` checks all managed positions for exit conditions BEFORE running strategies
  - After BUY execution, position registered with PositionManager
  - After strategy SELL, position removed from PositionManager
  - Partial exit (TP1): updates RiskManager position with remaining quantity
  - Full exit (SL, TP2, trailing): removes from both PositionManager and RiskManager
  - Added `take_profit_pct`, `trailing_stop_enabled`, `trailing_stop_pct` to Settings in config.py
  - Exported `PositionManager` and `ExitType` from `execution/__init__.py`
- **Files created:**
  - `src/bot/execution/position_manager.py` — PositionManager, ManagedPosition, ExitSignal, ExitType
  - `tests/execution/test_position_manager.py` — 32 unit tests
  - `tests/test_v2_008_position_manager.py` — 16 integration tests (wiring, config)
- **Files modified:**
  - `src/bot/main.py` — import PositionManager/ExitType, create in initialize(), check exits in _trading_cycle(), register on BUY, _execute_exit() helper
  - `src/bot/config.py` — added take_profit_pct, trailing_stop_enabled, trailing_stop_pct settings
  - `src/bot/execution/__init__.py` — exported PositionManager, ExitType
- **Tests:** 419 tests passing (371 previous + 48 new), ruff check passes
- **Learnings for future iterations:**
  - Trailing stop with trailing_stop_pct < stop_loss_pct would override the original SL from entry; fix: only apply trailing after price moves above entry_price
  - Float precision: use `pytest.approx()` for price calculations like `3000 * 1.10`
  - When testing exit-before-strategy ordering, use tracked functions with a call_order list, but make sure async mocks return values directly (not coroutines returning coroutines)
  - Partial exits need special handling in RiskManager: call `add_position()` with reduced quantity (overwrites) rather than `remove_position()`
  - TP1 check fires before TP2 check (TP1 price < TP2 price), so if price gaps past both, TP1 triggers first; TP2 triggers on next cycle
---
