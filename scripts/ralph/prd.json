{
  "project": "CoinTradingBot-Improvements",
  "branchName": "ralph/v2-improvements",
  "description": "Critical bug fixes, security hardening, missing integrations, and quality improvements for the crypto trading bot",
  "userStories": [
    {
      "id": "FIX-001",
      "title": "Fix pickle deserialization vulnerability in ML strategy",
      "description": "As a security-conscious developer, I need to replace unsafe pickle.load() with joblib to prevent arbitrary code execution from malicious model files.",
      "acceptanceCriteria": [
        "Replace pickle with joblib for model save/load in src/bot/strategies/ml/prediction.py",
        "Add joblib to dependencies in pyproject.toml and requirements.txt",
        "save_model() uses joblib.dump()",
        "_load_model() uses joblib.load()",
        "Existing test_save_and_load_model test still passes",
        "Remove pickle import entirely",
        "pytest passes, ruff check passes"
      ],
      "priority": 1,
      "passes": false,
      "notes": "CWE-502: Deserialization of Untrusted Data. pickle.load() can execute arbitrary code."
    },
    {
      "id": "FIX-002",
      "title": "Fix Dashboard XSS and add CORS protection",
      "description": "As a security-conscious operator, I need the dashboard to properly escape HTML output and restrict cross-origin requests.",
      "acceptanceCriteria": [
        "All user/trade data in HTML dashboard is escaped with html.escape()",
        "Add CORSMiddleware to FastAPI app with configurable allowed_origins (default: localhost only)",
        "Add allowed_origins setting to config.py (default: ['http://localhost:8000'])",
        "Dashboard still renders correctly with escaped data",
        "Unit tests for dashboard endpoints still pass",
        "Add test verifying HTML escaping works",
        "pytest passes, ruff check passes"
      ],
      "priority": 2,
      "passes": false,
      "notes": "XSS via f-string HTML in dashboard/app.py lines 77-82"
    },
    {
      "id": "FIX-003",
      "title": "Wire Dashboard to TradingBot orchestrator",
      "description": "As an operator, I need the dashboard to show real-time bot status, trades, metrics, and portfolio data instead of empty defaults.",
      "acceptanceCriteria": [
        "TradingBot.initialize() imports and calls dashboard.update_state(status='running')",
        "After each trading cycle, update dashboard state with: latest trades from DataStore, portfolio value, bot status",
        "TradingBot.shutdown() updates dashboard state to status='stopped'",
        "Dashboard /trades endpoint returns actual recent trades",
        "Dashboard /metrics endpoint returns calculated metrics from MetricsCollector",
        "Dashboard /portfolio endpoint returns current portfolio snapshot",
        "Start dashboard server in background (uvicorn) during bot.initialize() on configured port",
        "Unit tests verify dashboard state updates during bot lifecycle",
        "pytest passes, ruff check passes"
      ],
      "priority": 3,
      "passes": false,
      "notes": "Currently dashboard _bot_state is never updated from main.py"
    },
    {
      "id": "FIX-004",
      "title": "Integrate Telegram notifications into orchestrator",
      "description": "As an operator, I need the bot to actually send Telegram alerts for trade executions, daily summaries, and errors.",
      "acceptanceCriteria": [
        "TradingBot.initialize() creates TelegramNotifier if bot_token and chat_id are configured",
        "After successful order execution, call notifier.notify_trade()",
        "On trading_cycle_error, call notifier.notify_error()",
        "Send startup and shutdown notifications",
        "Gracefully skip notifications if Telegram is not configured (no crash)",
        "Unit tests with mocked Telegram verify notifications are triggered",
        "pytest passes, ruff check passes"
      ],
      "priority": 4,
      "passes": false,
      "notes": "TelegramNotifier exists but is never instantiated or called from main.py"
    },
    {
      "id": "FIX-005",
      "title": "Use ResilientExchange wrapper in orchestrator",
      "description": "As an operator, I need exchange API calls to use the circuit breaker and auto-retry logic that was already built.",
      "acceptanceCriteria": [
        "TradingBot._init_exchanges() wraps each ExchangeAdapter in ResilientExchange",
        "Circuit breaker protects all exchange calls (get_ticker, get_ohlcv, create_order)",
        "When circuit breaker trips, log warning and skip that exchange gracefully",
        "ResilientExchange implements full ExchangeAdapter interface (get_balance, cancel_order, get_order_status, get_order_book) via _call_with_breaker",
        "Existing exchange and execution tests still pass",
        "Add test for circuit breaker integration in orchestrator",
        "pytest passes, ruff check passes"
      ],
      "priority": 5,
      "passes": false,
      "notes": "ResilientExchange exists in execution/resilient.py but main.py creates raw adapters"
    },
    {
      "id": "FIX-006",
      "title": "Add paper trading portfolio balance tracking",
      "description": "As a paper trader, I need the simulated portfolio to track balances so I can see realistic results instead of having infinite capital.",
      "acceptanceCriteria": [
        "ExecutionEngine in paper mode tracks a simulated cash balance (configurable initial capital, default 10000)",
        "Paper BUY orders deduct from cash balance: cost = quantity * price + fee",
        "Paper SELL orders add to cash balance: proceeds = quantity * price - fee",
        "Reject paper orders if insufficient balance",
        "Track positions: add on BUY, remove on SELL",
        "Expose current balance and positions as properties",
        "Paper fee configurable (default 0.1%)",
        "Unit tests verify balance tracking across buy/sell cycles",
        "pytest passes, ruff check passes"
      ],
      "priority": 6,
      "passes": false,
      "notes": "Currently paper_execute() always succeeds with no balance check"
    },
    {
      "id": "FIX-007",
      "title": "Fix backtest P&L calculation and add buy fee accounting",
      "description": "As a trader, I need the backtesting engine to accurately calculate P&L including both buy and sell fees.",
      "acceptanceCriteria": [
        "Track the total cost of entering a position (buy_price * quantity + buy_fee)",
        "P&L = sell_proceeds - sell_fee - total_entry_cost",
        "Change pnl formula from `cash - (position_qty * position_entry)` to correct calculation",
        "Add test that verifies fee accounting: buy at $100, sell at $110 with 0.1% fee each way, verify exact P&L",
        "Existing backtest tests still pass (may need updating for correct math)",
        "pytest passes, ruff check passes"
      ],
      "priority": 7,
      "passes": false,
      "notes": "Line 99: pnl = cash - (position_qty * position_entry) doesn't account for buy fee"
    },
    {
      "id": "FIX-008",
      "title": "Add duplicate candle prevention and database indexes",
      "description": "As a developer, I need the data store to prevent duplicate candles and have proper indexes for query performance.",
      "acceptanceCriteria": [
        "Add UNIQUE constraint on (symbol, timeframe, timestamp) in OHLCVRecord model",
        "save_candles() uses INSERT OR IGNORE (or merge/upsert) to skip duplicates",
        "Add database indexes: (symbol, timeframe, timestamp) on OHLCVRecord, (symbol, created_at) on TradeRecord",
        "Existing data store tests pass with the new constraints",
        "Add test: saving the same candle twice doesn't create duplicates",
        "Add test: querying with indexes is functionally correct",
        "pytest passes, ruff check passes"
      ],
      "priority": 8,
      "passes": false,
      "notes": "Currently save_candles() blindly inserts, causing data bloat"
    },
    {
      "id": "FIX-009",
      "title": "Fix arbitrage same-exchange validation and DCA state mutation",
      "description": "As a trader, I need the arbitrage strategy to verify buy/sell are on different exchanges, and DCA to not mutate state during analysis.",
      "acceptanceCriteria": [
        "ArbitrageStrategy: after finding best_bid_exchange and best_ask_exchange, verify they are different; return HOLD if same",
        "Add test: when best bid and ask are from the same exchange, return HOLD signal",
        "DCAStrategy: only update _last_buy_time, _total_invested, _total_quantity AFTER returning the signal (or use a separate method)",
        "DCAStrategy: make analyze() idempotent - calling it twice with same data doesn't double-count",
        "Add test: calling DCA analyze() twice with same timestamp doesn't double the invested amount",
        "pytest passes, ruff check passes"
      ],
      "priority": 9,
      "passes": false,
      "notes": "Arbitrage: no check at line 65-67. DCA: mutates state at lines 101-104"
    },
    {
      "id": "FIX-010",
      "title": "Connect RiskManager to execution pipeline properly",
      "description": "As a trader, I need the risk manager to track open positions and P&L from actual executions, not just validate signals in isolation.",
      "acceptanceCriteria": [
        "After successful BUY execution, call risk_manager.add_position(symbol, qty, price)",
        "After successful SELL execution, call risk_manager.remove_position(symbol) and risk_manager.record_trade_pnl(pnl)",
        "Periodically call risk_manager.update_portfolio_value() with current total value",
        "Reset daily P&L at midnight (or on first cycle of new day)",
        "Add test: after a buy, risk manager blocks duplicate position for same symbol",
        "Add test: after hitting daily loss limit, subsequent signals are rejected",
        "pytest passes, ruff check passes"
      ],
      "priority": 10,
      "passes": false,
      "notes": "main.py calls validate_signal but never add_position/remove_position/record_trade_pnl"
    },
    {
      "id": "FIX-011",
      "title": "Add trading cycle overlap prevention and proper error logging",
      "description": "As an operator, I need the trading loop to prevent overlapping cycles and log errors with full tracebacks.",
      "acceptanceCriteria": [
        "Add asyncio.Lock to prevent concurrent _trading_cycle() calls",
        "If a cycle is still running when the next interval fires, skip (log warning) instead of overlapping",
        "Change logger.error('trading_cycle_error', error=str(e)) to include exc_info=True for full traceback",
        "Add structured error context (cycle_number, elapsed_time) to error logs",
        "Add test: verify lock prevents overlapping cycles",
        "pytest passes, ruff check passes"
      ],
      "priority": 11,
      "passes": false,
      "notes": "main.py:127-133 has no overlap protection and swallows tracebacks"
    },
    {
      "id": "FIX-012",
      "title": "Fix Docker multi-stage build and add resource limits",
      "description": "As a devops engineer, I need the Docker build to not install dependencies twice and to have proper resource limits.",
      "acceptanceCriteria": [
        "Dockerfile: remove redundant `pip install -e .` in runtime stage (already copied from builder)",
        "Runtime stage only copies installed packages from builder, not reinstalls",
        "docker-compose.yml: add deploy.resources.limits (memory: 512M, cpus: '1.0')",
        "docker-compose.yml: add deploy.resources.reservations (memory: 256M)",
        "Verify `docker build .` succeeds (if Docker is available, otherwise just verify file correctness)",
        "ruff check passes"
      ],
      "priority": 12,
      "passes": false,
      "notes": "Dockerfile lines 7 and 23 both install. Compose has no resource limits."
    },
    {
      "id": "FIX-013",
      "title": "Add backtest integration with RiskManager and result export",
      "description": "As a trader, I need backtests to apply risk rules (stop-loss, position limits) and export results to JSON/CSV.",
      "acceptanceCriteria": [
        "BacktestEngine accepts optional RiskManager parameter",
        "When RiskManager is provided, signals pass through validate_signal() before execution",
        "Stop-loss: if position is open and price drops below stop-loss level, auto-sell",
        "BacktestResult.to_json() serializes results to JSON string",
        "BacktestResult.to_csv() exports trade log to CSV string",
        "Add CLI entry point: python -m bot.backtest --strategy ma_crossover --symbol BTC/USDT",
        "Unit tests for risk-integrated backtest pass",
        "pytest passes, ruff check passes"
      ],
      "priority": 13,
      "passes": false,
      "notes": ""
    },
    {
      "id": "FIX-014",
      "title": "Add per-strategy performance tracking and portfolio snapshots",
      "description": "As an operator, I need to see how each strategy is performing individually and have periodic portfolio snapshots saved.",
      "acceptanceCriteria": [
        "MetricsCollector tracks per-strategy metrics: trades, win_rate, total_pnl per strategy name",
        "record_trade() accepts strategy_name parameter",
        "calculate() returns both overall and per_strategy metrics",
        "TradingBot saves portfolio snapshot to DataStore every N cycles (configurable, default: every 10 cycles)",
        "Dashboard /metrics endpoint includes per-strategy breakdown",
        "Unit tests for per-strategy tracking pass",
        "pytest passes, ruff check passes"
      ],
      "priority": 14,
      "passes": false,
      "notes": ""
    },
    {
      "id": "FIX-015",
      "title": "Comprehensive integration test for the improved pipeline",
      "description": "As a developer, I need an end-to-end test that verifies the full improved pipeline: data collection → strategy → risk check (with position tracking) → execution (with balance tracking) → dashboard update → notification.",
      "acceptanceCriteria": [
        "Integration test creates TradingBot with mocked exchanges returning a known price sequence",
        "Test runs 3+ trading cycles with a strategy that generates BUY then SELL signals",
        "Verify: paper portfolio balance decreases after BUY, increases after SELL",
        "Verify: risk manager tracks the open position after BUY",
        "Verify: risk manager removes position after SELL",
        "Verify: dashboard state is updated with trade data after each cycle",
        "Verify: Telegram notifier is called (mocked) on trade execution",
        "Verify: metrics show correct win/loss after completed trade",
        "All existing integration tests still pass",
        "pytest passes, ruff check passes"
      ],
      "priority": 15,
      "passes": false,
      "notes": "This validates that all FIX-001 through FIX-014 work together correctly"
    }
  ]
}
